b-tree
======

Основные характеристики b-дерева:
 - каждый узел, кроме корня, содержит не менее t - 1 ключей, и каждый внутренний узел имеет по меньшей мере t дочерних узлов. Если дерево не является пустым, корень должен содержать как минимум один ключ;
 - Каждый узел, кроме корня, содержит не более 2t - 1 ключей и не более чем 2t сыновей во внутренних узлах;
 - Корень содержит от 1 до 2t - 1 ключей, если дерево не пусто и от 2 до 2t детей при высоте большей 0.
 - Каждый узел дерева, кроме листьев, содержащий ключи k_1, ..., k_n, имеет n + 1 сына. i-й сын содержит ключи из отрезка [k_{i - 1}; k_i],\:  k_0 = -\infty,\: k_{n + 1} = \infinity;
 - Ключи в каждом узле упорядочены по неубыванию;
 - Все листья находятся на одном уровне.
 - t - разрядность дерева. 
t >= 2
t -1 <= node.keys <= 2t -1
t <= node.childs <= 2t

1 <= root.keys <= 2t - 1
0 <= root.childs <= 2t

высота дерева:
h <= logt((n + 1) / 2)



Операции над b-деревом
======

Поиск ключа
	Если ключ содержится в текущем узле, возвращаем его. Иначе определяем интервал и переходим к 
		соответствующему сыну. Повторяем пока ключ не найден или не дошли до листа.

Добавление
	 - добавление новых ключей всегда осуществляется в листья
	 - спускаемся по дереву и ищем лист, в который можно добавить ключ, рекурсивно вызывая добавление для 
		дочерней ноды
	 - как только доходим до листа - вставляем в него новый ключ
	 - после того, как вызвали добавление для дочерней ноды - проверяем, не стало ли в ней элементо больше, 
	 	чем 2t - 1. Если больше - вызываем split.
	 - split - делим ноду пополам, средний ключ вставляем в родительскую ноду
	 - в самом конце, когда вышли из рекурсивоной вставки, проверяем количество элементов в корне. Если в корне 
		элементов больше, чем 2t - 1, - делим ноду пополам, средний ключ становится корнем, высота дерева 
		увеличивается
	
	
Удаление
	
	 - вызываем рекурсивное удаление ключа для корня
	удаление из листа
	 - удаляем ключ
	 - если после удаления ключа в узле осталось менее t - 1 ключей 
		 - проверяем, если есть правый сосед и он содержит большое 2t - 1 ключей - берем его первый элемент и 
		 помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между текущим и 
		 соседним правым опускаем в текущую ноду
		 - иначе проверяем, если есть левый сосед и он содержит большое 2t - 1 ключей - берем его последний 
		 элемент и помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между 
		 текущим и соседним левым опускаем в текущую ноду
		 - если справа и слева ноды содержат минимальное количество ключей - 2t - 1 - объединяем текущую ноду с 
		одной из соседних (если есть правая, если нет - с левой) и опускаем в эту ноду ключ, разделяющий текущую 
		 ноду с той, с которой выполняем слияние
		
	удаление из узла
	 - если в левой дочерней относительно удаляемого ключа ключей больше чем t - 1 -
		находим максимальный элемент в ее поддереве и удаляем его рекурсивно.
		Значение максимального элемента помещаем на место удаляемого элемента
	 - если в правой дочерней относительно удаляемого ключа ключей больше чем t - 1 - 
		находим минимальный элемент в ее поддереве и удаляем его рекурсивно.
		Значение минимального помещаем на место удаляемого
	 - если в самой ноде ключей больше, чем t - 1 - объединяем две дочерние ноды, переносим в новую ноду
	 удаляемый ключ и запускаем его рекурсивное удаление
	  - если в левой соседней ноде ключей больше, чем t - 1 - переносим последнего потомка в 
		начало текущей ноды, ключ-разделитель из родительской ноды добавляем в начало текущей ноды,
		а последний ключ из соседнего потомка поднимаем в родителя на место ключа-разделителя
		
	 - если в правой соседней ноде ключей больше, чем t - 1 - переносим первого потомка в 
		начало текущей ноды, ключ-разделитель из родителя опускаем в начало текущей ноды, а первый ключ из соседа
		помещаем в родителя на место ключа-разделителя
	 - если же у обоих соседей минимальное количество ключей - надо объединиться с одним из них.
		если у соседа слева минимальное количество ключей - объединяемся с ним и опускаем ключ-разделитель из
			родительской ноды в новую ноду
		если у соседа справа минимальное количество ключей - объединяемся с ним и опускаем ключ-разделитель из
			родительской ноды в новую ноду
		если мы находимся на родительской ноде и в ней нет ключей - поместить в корень первого потомка корня
	 - после удаления надо обязательно проверять, достаточно ли в ноде ключей.
		если ключей недостаточно - надо запустить алгоритм объединения нод


Литература:

http://neerc.ifmo.ru/wiki/index.php?title=B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE#.D0.A3.D0.B4.D0.B0.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D1.8E.D1.87.D0.B0

http://habrahabr.ru/post/114154/

http://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE

http://citforum.ru/programming/theory/sorting/sorting2.shtml#5

http://www.cse.ohio-state.edu/~gurari/course/cis680/cis6802.html#QQ2-45-87
