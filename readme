Работа с b-деревом

Поиск ключа
	Если ключ содержится в текущем узле, возвращаем его. Иначе определяем интервал и переходим к 
		соответствующему сыну. Повторяем пока ключ не найден или не дошли до листа.

Добавление
	 - добавление новых ключей всегда осуществляется в листья
	 - спускаемся по дереву и ищем лист, в который можно добавить ключ, рекурсивно вызывая добавление для 
		дочерней ноды
	 - как только доходим до листа - вставляем в него новый ключ
	 - после того, как вызвали добавление для дочерней ноды - проверяем, не стало ли в ней элементо больше, 
	 	чем 2t - 1. Если больше - вызываем split.
	 - split - делим ноду пополам, средний ключ вставляем в родительскую ноду
	 - в самом конце, когда вышли из рекурсивоной вставки, проверяем количество элементов в корне. Если в корне 
		элементов больше, чем 2t - 1, - делим ноду пополам, средний ключ становится корнем, высота дерева 
		увеличивается
	
	
Удаление
	
	 - вызываем рекурсивное удаление ключа для корня
	удаление из листа
	 - удаляем ключ
	 - если после удаления ключа в узле осталось менее t - 1 ключей 
		 - проверяем, если есть правый сосед и он содержит большое 2t - 1 ключей - берем его первый элемент и 
		 помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между текущим и 
		 соседним правым опускаем в текущую ноду
		 - иначе проверяем, если есть левый сосед и он содержит большое 2t - 1 ключей - берем его последний 
		 элемент и помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между 
		 текущим и соседним левым опускаем в текущую ноду
		 - если справа и слева ноды содержат минимальное количество ключей - 2t - 1 - объединяем текущую ноду с 
		одной из соседних (если есть правая, если нет - с левой) и опускаем в эту ноду ключ, разделяющий текущую 
		 ноду с той, с которой выполняем слияние
		
	удаление из узла
	 - если в левой дочерней относительно удаляемого ключа ключей больше чем t - 1 -
		находим максимальный элемент в ее поддереве и удаляем его рекурсивно.
		Значение максимального элемента помещаем на место удаляемого элемента
	 - если в правой дочерней относительно удаляемого ключа ключей больше чем t - 1 - 
		находим минимальный элемент в ее поддереве и удаляем его рекурсивно.
		Значение минимального помещаем на место удаляемого
	 - если в самой ноде ключей больше, чем t - 1 - объединяем две дочерние ноды, переносим в новую ноду
	 удаляемый ключ и запускаем его рекурсивное удаление
	  - если в левой соседней ноде ключей больше, чем t - 1 - переносим последнего потомка в 
		начало текущей ноды, ключ-разделитель из родительской ноды добавляем в начало текущей ноды,
		а последний ключ из соседнего потомка поднимаем в родителя на место ключа-разделителя
		
	 - если в правой соседней ноде ключей больше, чем t - 1 - переносим первого потомка в 
		начало текущей ноды, ключ-разделитель из родителя опускаем в начало текущей ноды, а первый ключ из соседа
		помещаем в родителя на место ключа-разделителя
	 - если же у обоих соседей минимальное количество ключей - надо объединиться с одним из них.
		если у соседа слева минимальное количество ключей - объединяемся с ним и опускаем ключ-разделитель из
			родительской ноды в новую ноду
		если у соседа справа минимальное количество ключей - объединяемся с ним и опускаем ключ-разделитель из
			родительской ноды в новую ноду
		если мы находимся на родительской ноде и в ней нет ключей - поместить в корень первого потомка корня
	 - после удаления надо обязательно проверять, достаточно ли в ноде ключей.
		если ключей недостаточно - надо запустить алгоритм объединения нод