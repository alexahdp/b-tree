Работа с b-деревом

Поиск ключа
	Если ключ содержится в текущем узле, возвращаем его. Иначе определяем интервал и переходим к 
		соответствующему сыну. Повторяем пока ключ не найден или не дошли до листа.

Добавление
	 - добавление новых ключей всегда осуществляется в листья
	 - спускаемся по дереву и ищем лист, в который можно добавить ключ, рекурсивно вызывая добавление для 
		дочерней ноды
	 - как только доходим до листа - вставляем в него новый ключ
	 - после того, как вызвали добавление для дочерней ноды - проверяем, не стало ли в ней элементо больше, 
	 	чем 2t - 1. Если больше - вызываем split.
	 - split - делим ноду пополам, средний ключ вставляем в родительскую ноду
	 - в самом конце, когда вышли из рекурсивоной вставки, проверяем количество элементов в корне. Если в корне 
		элементов больше, чем 2t - 1, - делим ноду пополам, средний ключ становится корнем, высота дерева 
		увеличивается
	
	
Удаление
	
	 - вызываем рекурсивное удаление ключа для корня
	удаление из листа
	 - удаляем ключ
	 - если после удаления ключа в узле осталось менее t - 1 ключей 
		 - проверяем, если есть правый сосед и он содержит большое 2t - 1 ключей - берем его первый элемент и 
		 помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между текущим и 
		 соседним правым опускаем в текущую ноду
		 - иначе проверяем, если есть левый сосед и он содержит большое 2t - 1 ключей - берем его последний 
		 элемент и помещаем его в родительскую ноду, а элемент из родительской ноды, который располагается между 
		 текущим и соседним левым опускаем в текущую ноду
		 - если справа и слева ноды содержат минимальное количество ключей - 2t - 1 - объединяем текущую ноду с 
		одной из соседних (если есть правая, если нет - с левой) и опускаем в эту ноду ключ, разделяющий текущую 
		 ноду с той, с которой выполняем слияние
		
	удаление из узла
	 - если в левой дочерней относительно удаляемого ключа ключей больше чем t - 1 - 
		переносим последний ключ из нее на место удаляемого ключа k, и запускаем для нее рекурсивное 
		удаление ключа
	 - если в правой дочерней относительно удаляемого ключа ключей больше чем t - 1 - 
		переносим первый ключ из нее на место удаляемого ключа k, и запускаем для нее рекурсивное 
		удаление ключа
	 - если в самой ноде ключей больше, чем t - 1 - объединяем две дочерние ноды, переносим в новую ноду
	 удаляемый ключ и запускаем его рекурсивное удаление
	  - если в левой соседней ноде ключей больше, чем t - 1 - переносим последний ключ с последним поддеревом в 
		текущую ноду и запускаем рекурсивное удаление ключа
	 - если в правой соседней ноде ключей больше, чем t - 1 - переносим первый ключ с первым поддеревом в 
		текущую ноду и запускаем рекурсивное удаление ключа
	 ---- блять, что делать если справа, слева и снизу везде ключей ровно 2t - 1?????
		Как я понял:
		переносим ключ из дочерней ноды (удаляем рукурсивно), затем вызываем слияние